import { Actor, ActorSubclass, HttpAgent } from "@dfinity/agent";
import type { Identity } from "@dfinity/agent";
import type { IDL } from "@dfinity/candid";
import {
  idlFactory as daoBackendIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as DaoBackendService
} from "../declarations/dao_backend/dao_backend.did";
import {
  idlFactory as governanceIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as GovernanceService
} from "../declarations/governance/governance.did";
import {
  idlFactory as proposalsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as ProposalsService
} from "../declarations/proposals/proposals.did";
import {
  idlFactory as stakingIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as StakingService
} from "../declarations/staking/staking.did";
import {
  idlFactory as treasuryIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as TreasuryService
} from "../declarations/treasury/treasury.did";

declare global {
  interface Window {
    global: typeof globalThis;
  }
}

// Ensure global is defined in the browser context
if (typeof window !== "undefined") {
  window.global = window;
}

const createActor = async <T>(
  canisterId: string,
  idlFactory: IDL.InterfaceFactory,
  identity?: Identity
): Promise<ActorSubclass<T>> => {
  try {
    const agent = new HttpAgent({
      host: import.meta.env.VITE_HOST || "http://localhost:4943",
      verifyQuerySignatures: false,
      identity,
    });

    if (identity) {
      const principal = await agent.getPrincipal();
      console.log("HttpAgent principal:", principal.toString());
    }

    // Only fetch the root key when we're in development
    if (import.meta.env.VITE_DFX_NETWORK !== "ic") {
      await agent.fetchRootKey().catch(err => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }

    return Actor.createActor<T>(idlFactory, {
      agent,
      canisterId,
    });
  } catch (error) {
    console.error("Error creating actor:", error);
    throw error;
  }
};

export const initializeAgents = async (identity?: Identity) => {
  try {
    const daoBackend = await createActor<DaoBackendService>(
      import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
      daoBackendIdl,
      identity
    );
    const governance = await createActor<GovernanceService>(
      import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
      governanceIdl,
      identity
    );
    const proposals = await createActor<ProposalsService>(
      import.meta.env.VITE_CANISTER_ID_PROPOSALS,
      proposalsIdl,
      identity
    );
    const staking = await createActor<StakingService>(
      import.meta.env.VITE_CANISTER_ID_STAKING,
      stakingIdl,
      identity
    );
    const treasury = await createActor<TreasuryService>(
      import.meta.env.VITE_CANISTER_ID_TREASURY,
      treasuryIdl,
      identity
    );

    return {
      daoBackend,
      governance,
      proposals,
      staking,
      treasury,
    };
  } catch (error) {
    console.error("Failed to initialize actors:", error);
    throw error;
  }
};
