import { Actor, ActorSubclass, HttpAgent } from "@dfinity/agent";
import type { Identity } from "@dfinity/agent";
import type { IDL } from "@dfinity/candid";
import {
  idlFactory as daoBackendIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as DaoBackendService
} from "../declarations/dao_backend/dao_backend.did.js";
import {
  idlFactory as governanceIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as GovernanceService
} from "../declarations/governance/governance.did.js";
import {
  idlFactory as proposalsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as ProposalsService
} from "../declarations/proposals/proposals.did.js";
import {
  idlFactory as stakingIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as StakingService
} from "../declarations/staking/staking.did.js";
import {
  idlFactory as treasuryIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as TreasuryService
} from "../declarations/treasury/treasury.did.js";
import {
  idlFactory as assetsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as AssetsService,
} from "../declarations/assets/assets.did.js";

declare global {
  interface Window {
    global: typeof globalThis;
  }
}

// Ensure global is defined in the browser context
if (typeof window !== "undefined") {
  window.global = window;
}

const createActor = async <T>(
  canisterId: string,
  idlFactory: IDL.InterfaceFactory,
  identity?: Identity
): Promise<ActorSubclass<T>> => {
  try {
    console.log("Creating actor for canister ID:", canisterId);
    
    // Check if canisterId is valid
    if (!canisterId || canisterId === 'undefined' || canisterId.includes('_')) {
      throw new Error(`Invalid canister ID: ${canisterId}`);
    }

    // Determine the correct host based on the environment
    let host = import.meta.env.VITE_HOST;
    
    // If we're in a canister environment, use the current window location
    if (typeof window !== 'undefined' && window.location.hostname.includes('.localhost')) {
      host = `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;
    } else if (!host) {
      host = "http://127.0.0.1:4943";
    }

    console.log("Using host:", host);

    const agent = new HttpAgent({
      host: host,
      verifyQuerySignatures: false,
      identity,
    });

    if (identity) {
      const principal = await agent.getPrincipal();
      console.log("HttpAgent principal:", principal.toString());
    }

    // Only fetch the root key when we're in development
    if (import.meta.env.VITE_DFX_NETWORK !== "ic") {
      await agent.fetchRootKey().catch(err => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }

    return Actor.createActor<T>(idlFactory, {
      agent,
      canisterId,
    });
  } catch (error) {
    console.error("Error creating actor:", error);
    throw error;
  }
};

export const initializeAgents = async () => {
  console.log("=== DEBUGGING ENVIRONMENT VARIABLES ===");
  console.log("All import.meta.env:", import.meta.env);
  
  const envVars = {
    'VITE_CANISTER_ID_DAO_BACKEND': import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
    'VITE_CANISTER_ID_GOVERNANCE': import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
    'VITE_CANISTER_ID_STAKING': import.meta.env.VITE_CANISTER_ID_STAKING,
    'VITE_CANISTER_ID_TREASURY': import.meta.env.VITE_CANISTER_ID_TREASURY,
    'VITE_CANISTER_ID_PROPOSALS': import.meta.env.VITE_CANISTER_ID_PROPOSALS,
    'VITE_CANISTER_ID_ASSETS': import.meta.env.VITE_CANISTER_ID_ASSETS,
    'VITE_CANISTER_ID_INTERNET_IDENTITY': import.meta.env.VITE_CANISTER_ID_INTERNET_IDENTITY,
  };

  Object.entries(envVars).forEach(([key, value]) => {
    console.log(`${key}:`, value);
    console.log(`  Type: ${typeof value}`);
    console.log(`  Length: ${value ? value.length : 'N/A'}`);
    console.log(`  Contains underscore: ${value ? value.includes('_') : 'N/A'}`);
    console.log(`  Raw characters:`, value ? [...value].map(c => `${c}(${c.charCodeAt(0)})`).join(' ') : 'N/A');
  });

  try {
    const [daoBackend, governance, staking, treasury, proposals, assets] = await Promise.all([
      createActor<DaoBackendService>(import.meta.env.VITE_CANISTER_ID_DAO_BACKEND, daoBackendIdl),
      createActor<GovernanceService>(import.meta.env.VITE_CANISTER_ID_GOVERNANCE, governanceIdl),
      createActor<StakingService>(import.meta.env.VITE_CANISTER_ID_STAKING, stakingIdl),
      createActor<TreasuryService>(import.meta.env.VITE_CANISTER_ID_TREASURY, treasuryIdl),
      createActor<ProposalsService>(import.meta.env.VITE_CANISTER_ID_PROPOSALS, proposalsIdl),
      createActor<AssetsService>(import.meta.env.VITE_CANISTER_ID_ASSETS, assetsIdl),
    ]);

    return {
      daoBackend,
      governance,
      staking,
      treasury,
      proposals,
      assets,
    };
  } catch (error) {
    console.error("Failed to initialize agents:", error);
    throw error;
  }
};
