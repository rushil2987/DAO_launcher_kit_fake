import { Actor, ActorSubclass, HttpAgent } from "@dfinity/agent";
import type { Identity } from "@dfinity/agent";
import type { IDL } from "@dfinity/candid";
import {
  idlFactory as daoBackendIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as DaoBackendService
} from "../declarations/dao_backend/dao_backend.did.js";
import {
  idlFactory as governanceIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as GovernanceService
} from "../declarations/governance/governance.did.js";
import {
  idlFactory as proposalsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as ProposalsService
} from "../declarations/proposals/proposals.did.js";
import {
  idlFactory as stakingIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as StakingService
} from "../declarations/staking/staking.did.js";
import {
  idlFactory as treasuryIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as TreasuryService
} from "../declarations/treasury/treasury.did.js";
import {
  idlFactory as assetsIdl,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - _SERVICE is generated by dfx at build time
  _SERVICE as AssetsService,
} from "../declarations/assets/assets.did.js";

declare global {
  interface Window {
    global: typeof globalThis;
  }
}

// Ensure global is defined in the browser context
if (typeof window !== "undefined") {
  window.global = window;
}

const createActor = async <T>(
  canisterId: string,
  idlFactory: IDL.InterfaceFactory,
  identity?: Identity
): Promise<ActorSubclass<T>> => {
  try {
    console.log("Creating actor for canister ID:", canisterId);
    
    // Check if canisterId is valid
    if (!canisterId || canisterId === 'undefined' || canisterId.includes('_')) {
      throw new Error(`Invalid canister ID: ${canisterId}`);
    }

    // Determine the correct host based on the environment
    let host = import.meta.env.VITE_HOST;
    
    // If we're in a canister environment, use the current window location
    if (typeof window !== 'undefined' && window.location.hostname.includes('.localhost')) {
      host = `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;
    } else if (!host) {
      host = "http://127.0.0.1:4943";
    }

    console.log("Using host:", host);

    const agent = new HttpAgent({
      host: host,
      verifyQuerySignatures: false,
      identity,
    });

    if (identity) {
      const principal = await agent.getPrincipal();
      console.log("HttpAgent principal:", principal.toString());
    }

    // Only fetch the root key when we're in development
    if (import.meta.env.VITE_DFX_NETWORK !== "ic") {
      await agent.fetchRootKey().catch(err => {
        console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
        console.error(err);
      });
    }

    return Actor.createActor<T>(idlFactory, {
      agent,
      canisterId,
    });
  } catch (error) {
    console.error("Error creating actor:", error);
    throw error;
  }
};


export const initializeAgents = async () => {
  if (import.meta.env.DEV) {
    console.log("=== DEBUGGING ENVIRONMENT VARIABLES ===");
    console.log("All import.meta.env:", import.meta.env);

    const envVars = {
      'VITE_CANISTER_ID_DAO_BACKEND': import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
      'VITE_CANISTER_ID_GOVERNANCE': import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
      'VITE_CANISTER_ID_STAKING': import.meta.env.VITE_CANISTER_ID_STAKING,
      'VITE_CANISTER_ID_TREASURY': import.meta.env.VITE_CANISTER_ID_TREASURY,
      'VITE_CANISTER_ID_PROPOSALS': import.meta.env.VITE_CANISTER_ID_PROPOSALS,
      'VITE_CANISTER_ID_ASSETS': import.meta.env.VITE_CANISTER_ID_ASSETS,
      'VITE_CANISTER_ID_INTERNET_IDENTITY': import.meta.env.VITE_CANISTER_ID_INTERNET_IDENTITY,
    };

    Object.entries(envVars).forEach(([key, value]) => {
      console.log(`${key}:`, value);
      console.log(`  Type: ${typeof value}`);
      console.log(`  Length: ${value ? value.length : 'N/A'}`);
      console.log(`  Contains underscore: ${value ? value.includes('_') : 'N/A'}`);
      console.log(
        `  Raw characters:`,
        value ? [...value].map(c => `${c}(${c.charCodeAt(0)})`).join(' ') : 'N/A'
      );
    });
  }


  try {
    // Create actors for required canisters
    const daoBackend = await createActor<DaoBackendService>(
      import.meta.env.VITE_CANISTER_ID_DAO_BACKEND,
      daoBackendIdl,
      identity
    );

    const assets = await createActor<AssetsService>(
      import.meta.env.VITE_CANISTER_ID_ASSETS,
      assetsIdl,
      identity
    );

    // Create mock actors for optional canisters if they don't exist
    // This prevents errors during development when not all canisters are deployed
    const createMockActor = <T>(): ActorSubclass<T> => {
      return new Proxy({} as ActorSubclass<T>, {
        get: (target, prop) => {
          if (typeof prop === 'string') {
            return async (...args: any[]) => {
              console.warn(`Mock actor method called: ${prop}`, args);
              // Return mock data based on the method name
              if (prop.includes('get') || prop.includes('fetch') || prop.includes('list')) {
                return null; // Query methods return null for now
              }
              return { ok: true }; // Update methods return success
            };
          }
          return target[prop as keyof ActorSubclass<T>];
        }
      });
    };

    // Try to create real actors, fall back to mock actors
    let governance: ActorSubclass<GovernanceService>;
    let staking: ActorSubclass<StakingService>;
    let treasury: ActorSubclass<TreasuryService>;
    let proposals: ActorSubclass<ProposalsService>;

    try {
      if (import.meta.env.VITE_CANISTER_ID_GOVERNANCE) {
        governance = await createActor<GovernanceService>(
          import.meta.env.VITE_CANISTER_ID_GOVERNANCE,
          governanceIdl,
          identity
        );
      } else {
        governance = createMockActor<GovernanceService>();
      }
    } catch (error) {
      console.warn("Failed to create governance actor, using mock:", error);
      governance = createMockActor<GovernanceService>();
    }

    try {
      if (import.meta.env.VITE_CANISTER_ID_STAKING) {
        staking = await createActor<StakingService>(
          import.meta.env.VITE_CANISTER_ID_STAKING,
          stakingIdl,
          identity
        );
      } else {
        staking = createMockActor<StakingService>();
      }
    } catch (error) {
      console.warn("Failed to create staking actor, using mock:", error);
      staking = createMockActor<StakingService>();
    }

    try {
      if (import.meta.env.VITE_CANISTER_ID_TREASURY) {
        treasury = await createActor<TreasuryService>(
          import.meta.env.VITE_CANISTER_ID_TREASURY,
          treasuryIdl,
          identity
        );
      } else {
        treasury = createMockActor<TreasuryService>();
      }
    } catch (error) {
      console.warn("Failed to create treasury actor, using mock:", error);
      treasury = createMockActor<TreasuryService>();
    }

    try {
      if (import.meta.env.VITE_CANISTER_ID_PROPOSALS) {
        proposals = await createActor<ProposalsService>(
          import.meta.env.VITE_CANISTER_ID_PROPOSALS,
          proposalsIdl,
          identity
        );
      } else {
        proposals = createMockActor<ProposalsService>();
      }
    } catch (error) {
      console.warn("Failed to create proposals actor, using mock:", error);
      proposals = createMockActor<ProposalsService>();
    }

    return {
      daoBackend,
      governance,
      staking,
      treasury,
      proposals,
      assets,
    };
  } catch (error) {
    console.error("Failed to initialize agents:", error);
    throw error;
  }
};
